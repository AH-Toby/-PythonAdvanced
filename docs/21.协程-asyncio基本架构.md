# asyncio的基本架构

## 一.按时asyncio高层API方法

### 1.运行协程

结构：

```python
asyncio.run(coro,*,debug=Fals)
```

参数：

`coro`：要运行的协程对象。这是必需的参数，应该是一个异步函数或协程对象。

`debug`：一个可选的布尔值，用于启用或禁用调试模式。如果将其设置为 `True`，则会启用事件循环的调试模式，以便更容易追踪问题。默认为 `False`。

```python
import asyncio


async def my_coroutine():
    await asyncio.sleep(1)
    print("Coroutine completed")


asyncio.run(my_coroutine())  # 运行协程
```

### 2.创建任务

结构：

```python
task=asyncio.create_task(coro)
```

参数：

`coro`：要运行的协程对象。这是必需的参数，应该是一个异步函数或协程对象

作用：用于创建一个协程任务（`Task`）。这个函数允许您在事件循环中并发执行协程，并返回一个表示任务的 `Task` 对象。

```python
import asyncio


async def my_coroutine():
    await asyncio.sleep(1)
    print("Coroutine completed")


# 创建协程任务
task = asyncio.create_task(my_coroutine())
```

结构2：

```python
asyncio.ensure_future(coro_or_future, *, loop=None)
```

参数：

`coro_or_future`：要包装的协程对象或可等待对象。这是必需的参数。

`loop`：一个可选的事件循环对象，用于指定在哪个事件循环中创建任务。如果未指定，将使用默认事件循环。

```python
import asyncio

async def my_coroutine():
    await asyncio.sleep(1)
    print("Coroutine completed")

# 使用 ensure_future 创建协程任务
task = asyncio.ensure_future(my_coroutine())
```

与 `asyncio.create_task()` 不同，`asyncio.ensure_future()` 具有一个额外的参数 `loop`，可以用来指定在哪个事件循环中创建任务。如果不提供 `loop` 参数，它将使用默认的事件循环。

`asyncio.ensure_future()` 函数通常用于将非协程函数或其他可等待对象转化为协程任务。这使得您可以将各种异步操作包装成 `Task`，以便在事件循环中并发执行并进行管理。无论您是使用 `asyncio.create_task()` 还是 `asyncio.ensure_future()`，都可以方便地执行异步编程任务。

### 3.睡眠

结构：

```python
await asyncio.sleep(seconds, result=None, *, loop=None)
```

参数：

`seconds`：要休眠的时间，以秒为单位。可以是一个浮点数或整数，表示休眠的秒数。

`result`：可选的返回结果。当协程休眠完成后，它将产生这个结果。默认为 `None`。

`loop`：可选的事件循环对象，用于指定在哪个事件循环中运行休眠协程。如果不指定，将使用默认事件循环。

```python
import asyncio

async def my_coroutine():
    print("Start")
    await asyncio.sleep(2)  # 休眠2秒
    print("End")

asyncio.run(my_coroutine())
```

### 4.并发运行多个任务

结构：

```python
await asyncio.gather(*coros_or_futures, loop=None, return_exceptions=False)
```

参数：

`*coros_or_futures`：要同时运行的协程对象或可等待对象，作为可变参数传递给函数。您可以传递一个或多个协程函数或 `Future` 对象。

`loop`：可选的事件循环对象，用于指定在哪个事件循环中运行这些协程。如果不指定，将使用默认事件循环。

`return_exceptions`：一个可选的布尔值，用于控制是否在协程中出现异常时返回异常对象而不是引发异常。默认为 `False`，表示引发异常。 如果是true，对于已经发生了异常的任务，也会像成功执行了任务那样，等到所有的任务执行结束一起将错误的结果返回到最终的结果列表里面。

```python
import asyncio

async def coroutine1():
    await asyncio.sleep(1)
    print("Coroutine 1 completed")

async def coroutine2():
    await asyncio.sleep(2)
    print("Coroutine 2 completed")

async def main():
    # 同时运行两个协程
    await asyncio.gather(coroutine1(), coroutine2())
    print("Both coroutines completed")

asyncio.run(main())
```

### 5.防止任务取消

结构：

```python
await asyncio.shield(coro, *, loop=None)
```

参数：

`coro`：要保护的协程对象。这是必需的参数，应该是一个异步函数或协程对象。

`loop`：可选的事件循环对象，用于指定在哪个事件循环中运行这个协程。如果不指定，将使用默认事件循环。

作用：

它本身也是awaitable的。顾名思义，shield为屏蔽、保护的意思，即保护一个awaitable 对象防止取消，一般情况下不推荐使用，而且在使用的过程中，最好使用try语句块更好。

```python
import asyncio

async def my_coroutine():
    await asyncio.sleep(1)
    print("Coroutine completed")

async def main():
    # 创建一个协程任务并使用 asyncio.shield() 保护它
    task = asyncio.create_task(my_coroutine())
    await asyncio.shield(task)
    print("Task completed")

asyncio.run(main())
```

